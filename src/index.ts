import { PluginOption } from 'vite'
import {
  readFileSync,
  readdirSync,
  writeFileSync,
  statSync,
  mkdirSync
} from 'fs'
import { join, relative, dirname } from 'path'
import { type BinaryToTextEncoding, createHash } from 'crypto'

export interface VitePluginCheckVersionOptions {
  /** 指定版本文件的路径，相对于build.outDir
   * @example
   * ```
   * {
   *   // 下面三种配置是等价的，都会输出到${build.outDir}/version.json
   *   versionFile: 'version.json',
   *   versionFile: './version.json',
   *   versionFile: '/version.json',
   *   // 还可以配置更深的路径、其它文件名
   *   versionFile: '/path/to/path/whatever.json',
   * }
   * ```
   */
  versionFile?: string
  /** 指定版本文件的键名 */
  versionKey?: string
  /** 版本文件的哈希算法,即传递给`crypto.createHash(algorithm: string)`的algorithm参数 */
  hashAlgorithm?: string
  /** 哈希算法的编码方式，即传递给`crypto.createHash().digest(encoding: BinaryToTextEncoding)`的encoding参数 */
  encoding?: BinaryToTextEncoding
  /** 是否静默模式（静默则不自动生成和插入版本检测脚本，由开发者决策如何编写及何时执行脚本） */
  silent?: boolean
  /** 检测脚本的文件名 */
  checkScriptFile?: string
  /** 轮询间隔（毫秒） */
  pollInterval?: number
  /** 检测到新版本的提示文本 */
  checkTip?: string
}

export default function vitePluginCheckVersion(
  options: VitePluginCheckVersionOptions = {}
): PluginOption {
  const {
    versionFile = 'version.json',
    versionKey = 'version',
    hashAlgorithm = 'md5',
    encoding = 'hex',
    silent = false,
    checkScriptFile = 'version-check.js',
    pollInterval = 10 * 1000,
    checkTip = '发现新版本，是否立即刷新获取最新内容？'
  } = options

  // vite config.build.outDir
  let outDir: string
  // vite config.base
  let basePath = ''
  // vite config.publicDir
  let publicDir = ''
  let versionValue = ''

  return {
    name: 'vite-plugin-check-version',

    configResolved(config) {
      outDir = config.build.outDir
      basePath = config.base
      publicDir = config.publicDir
    },

    transformIndexHtml(html) {
      if (silent) return html

      // 自动注入检测脚本
      const scriptTag = `\n<script src="${join(basePath, checkScriptFile).replace(/\\/g, '/')}"></script>`
      if (/<\/head>/i.test(html)) {
        return html.replace(/<\/head>/i, `${scriptTag}\n</head>`)
      }
      return html + scriptTag
    },

    // 确保在构建完成后执行
    closeBundle: {
      order: 'post', // 确保在其他插件之后运行
      async handler() {
        // 计算index.html的hash
        const html = readFileSync(join(outDir, 'index.html'), 'utf-8')
        const htmlHash = createHash(hashAlgorithm).update(html).digest(encoding)

        // 计算public文件夹的hash
        let publicHash = ''
        if (statSync(publicDir, { throwIfNoEntry: false })?.isDirectory()) {
          publicHash = calcDirHash(publicDir, encoding)
        }

        // 合并生成最终版本号
        versionValue = createHash(hashAlgorithm)
          .update(htmlHash)
          .update(publicHash)
          .digest(encoding)

        if (silent) return
        // 确保writeFile目录存在
        const versionFilePath = join(outDir, versionFile)
        const versionDir = dirname(versionFilePath)
        if (!statSync(versionDir, { throwIfNoEntry: false })?.isDirectory()) {
          mkdirSync(versionDir, { recursive: true })
        }
        // 将版本号写入版本文件
        writeFileSync(
          versionFilePath,
          JSON.stringify({ [versionKey]: versionValue }, null, 2)
        )

        // 生成检测脚本
        const checkScriptPath = join(outDir, checkScriptFile)
        const versionFileUrl = join(basePath, versionFile).replace(/\\/g, '/')

        const checkScriptContent = `// Auto-generated by vite-plugin-check-version
(function() {
  var currentVersion = '${versionValue}';
  var pollInterval = ${pollInterval};
  var versionKey = '${versionKey}';
  var versionFile = '${versionFileUrl}';
  var checkUpdate = function() {
    fetch(versionFile + '?t=' + Date.now())
      .then(function(res) { return res.json(); })
      .then(function(data) {
        if (data[versionKey] && data[versionKey] !== currentVersion) {
          currentVersion = data[versionKey];
          showUpdateNotification();
        }
      });
  };

  var showUpdateNotification = function() {
    if (confirm('${checkTip}')) {
      location.reload();
    }
  };

  setInterval(checkUpdate, pollInterval);
  checkUpdate();
})();`

        mkdirSync(dirname(checkScriptPath), { recursive: true })
        writeFileSync(checkScriptPath, checkScriptContent)
      }
    }
  }
}

// 递归遍历目录
function walkDir(dir: string, callback: (path: string) => void) {
  readdirSync(dir).forEach(file => {
    const path = join(dir, file)
    if (statSync(path).isDirectory()) {
      walkDir(path, callback)
    } else {
      callback(path)
    }
  })
}

// 计算某个文件夹内所有文件的哈希值
function calcDirHash(dir: string, encoding: BinaryToTextEncoding): string {
  const hash = createHash('md5')
  const files: { path: string; content: Buffer }[] = []
  walkDir(dir, filePath => {
    const relativePath = relative(dir, filePath)
    const content = readFileSync(filePath)
    files.push({ path: relativePath, content })
  })

  // 对文件内容生成摘要
  files.sort((a, b) => a.path.localeCompare(b.path)) // 确保顺序一致
  files.forEach(({ content }) => {
    hash.update(content)
  })
  return hash.digest(encoding)
}
